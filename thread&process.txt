----------------------------------------------------------------
프로세스와 스레드의 차이
둘다 여러개의 작업을 동시에 처리하려는 동작을 합니다.
멀티 프로세스
멀티 스레드
​
프로세스는 프로그램 단위
하지만 스레드는 프로세스 내부의 코드 단위
​
프로세스
별도의 메모리 공간을 가지고 독립된 실행 동작 합니다.
​
독립된 메모리 공간이 필요할 때 사용
하지만 성능에 부담이 됩니다.
하나의 프로세스가 오류가 나도 나머지에는 영향을 주지 않습니다.
​
보통 프로세스를 복사해서 똑같은 동작을 시키도록 하는데 기존 프로세스를 부모 프로세스, 복사된 프로세스를 자식 프로세스라고 부릅니다.
​
기존 코드를 그대로 복사해서 똑같이 실행한 것이기 때문에
​
int process_id = fork(); // 기존 프로세스를 복사해 실행합니다.
if id<0 // -1이면 오류이므로 종료시킵니다.
if id==0 // 0이면 자식 프로세스의 동작이므로 자식 프로세스 동작을 집어넣습니다.
if id>0 // 부모 프로세스는 자식의 pid를 리턴받았기 때문에 여기에는 부모 프로세스의 동작을 집어넣습니다.
​
​
​
스레드
하나의 프로세스 내에서 여러 개의 멀티 스레드가 동작됩니다.
공유하는 메모리 공간을 가지고, cpu 코어를 공유하면서 프로세스 내에서 서로 작업을 나눔.
​
빠르고 가볍지만 공유된 메모리 공간을 사용하기 때문에 동기화 문제가 발생할 수 있습니다.
하나의 스레드가 오류를 일으키면, 나머지 스레드도 영향을 받게 됩니다.
​
하나의 데이터에 두개의 스레드가 동시에 접근하면 어떻게 대처해야 하는가?
-> 자바의 싱크로나이즈드, 리눅스의 mutex
------------------------------------------------------------------------------
멀티 프로세스
fork()는 부모와 똑같은 프로세스, 자식프로세스를 새로운 메모리 공간에서 실행
메모리 복사 과정 때문에 성능 저하를 일으킴
​
vfork()는 부모와 자식이 같은 메모리 공간을 공유하여 사용함. 자식 프로세스가 생성돼서 일을 시작하면 부모 프로세스는 자식이 끝날 때까지 대기함. 자식이 변경한 메모리는 부모에게도 그대로 영향이 감.
대신 메모리 공간을 공유함으로써 메모리 복사를 하지 않아도 돼 성능면에서 이득임. 하지만 메모리 변경의 우려가 있음.
그렇기 때문에 vfork()는 exec()류와 같이 사용함.
exec-()는 execute 실행 가능한 모든 프로그램을 실행하는 함수로,
해당 프로세스에서
리눅스에서 사용가능한 프로그램(명령어)
: 기본 유틸( ls, ps, pwd, grep, cat, echo ...)
파일 관리( cp, mv, rm, mkdir ...)
네트워크 도구(ping, curl, ssh, wget ...)
시스템 관리(top, htop, kill, df, du, free ...)
사용자가 만든 프로그램( c, c++ java ... 컴파일된 바이너리 파일 등)
을 실행시킬 수 있다.
이 말은 즉, fork()로 메모리 복사를 하지 않고, vfork()로 그냥 부모와 같은 메모리 공간을 사용하도록 한 뒤,(부모 프로세스는 대기 상태 until exec(), _exit)
즉시, exec()를 사용하여, 부모 프로세스는 그대로 작동하고, 자식 프로세스는 자식 프로세스대로 작동하도록 하게 할 수 있다.
​
즉, 메모리 복사는 하지 않고, 부모프로세스는 부모 프로세스대로 자식 프로세스는 자식 프로세스대로 작동하도록 하는 방법이다.

---------------------------------------------------------------------

system()
리눅스 명령어들을 코드 상에서 실행 가능

exec() 계열 함수
실제 실행 파일을 지정하여, 실제 파일을 실행합니다. 리눅스 명령어, 사용자가 만든 프로그램 등 다 실행 가능함
exec() 호출된 프로세스는 기존 프로세스를 "대체" 해버린다.
